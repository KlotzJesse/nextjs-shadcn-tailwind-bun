"use server";

import { db } from "../../lib/db";

import {
  areaChanges,
  areaUndoStacks,
  areaVersions,
  areas,
  areaLayers,
  areaLayerPostalCodes,
  type SelectAreaChanges,
} from "../../lib/schema/schema";

import { eq, and, desc, inArray, sql } from "drizzle-orm";

export type Transaction = Parameters<Parameters<typeof db.transaction>[0]>[0];

import { updateTag, unstable_cache } from "next/cache";

type ServerActionResponse<T = void> = Promise<{
  success: boolean;

  data?: T;

  error?: string;
}>;

export interface ChangeRecord {
  changeType: string;

  entityType: string;

  entityId?: number;

  changeData: Record<string, unknown>;

  previousData?: Record<string, unknown>;

  createdBy?: string;
}

interface LayerData {
  id: number;
  areaId: number;
  name: string;
  color: string;
  opacity: number;
  isVisible: string;
  orderIndex: number;
}

interface ChangeDataWithLayer extends Record<string, unknown> {
  layer?: LayerData;
  postalCodes?: string[];
}

interface PreviousDataWithLayer extends Record<string, unknown> {
  layer?: LayerData;
  postalCodes?: string[];
}

export interface ChangeKey {
  areaId: number;

  versionAreaId: number | null;

  versionNumber: number | null;

  sequenceNumber: number;
}

// ===============================

// CHANGE RECORDING

// ===============================

/**
 * Record a change in the change tracking system
 */

export async function recordChangeAction(
  areaId: number,

  change: ChangeRecord,
): ServerActionResponse<ChangeKey> {
  try {
    // Get current active version if exists

    const area = await db.query.areas.findFirst({
      where: eq(areas.id, areaId),

      columns: { currentVersionNumber: true },
    });

    if (!area || !area.currentVersionNumber) {
      return { success: false, error: "Area not found" };
    }

    // Insert the change - sequenceNumber will be auto-generated by trigger
    const [newChange] = await db

      .insert(areaChanges)

      .values({
        areaId,

        changeType: change.changeType,

        entityType: change.entityType,

        entityId: change.entityId,

        changeData: change.changeData,

        previousData: change.previousData,

        versionAreaId: area?.currentVersionNumber ? areaId : null,

        versionNumber: area?.currentVersionNumber || null,

        // sequenceNumber will be auto-generated by trigger - don't pass it

        createdBy: change.createdBy,
      })

      .returning();

    // Update undo stack with composite key

    const changeKey: ChangeKey = {
      areaId: newChange.areaId,

      versionAreaId: newChange.versionAreaId,

      versionNumber: newChange.versionNumber,

      sequenceNumber: newChange.sequenceNumber,
    };

    await updateUndoStackAfterChange(areaId, changeKey);

    // Update version change count if there's an active version

    if (area?.currentVersionNumber) {
      await db

        .update(areaVersions)

        .set({
          changeCount: sql`${areaVersions.changeCount} + 1`,
        })

        .where(
          and(
            eq(areaVersions.areaId, areaId),

            eq(areaVersions.versionNumber, area.currentVersionNumber),
          ),
        );
    }

    updateTag("undo-redo-status");

    return { success: true, data: changeKey };
  } catch (error) {
    console.error("Error recording change:", error);

    return { success: false, error: "Failed to record change" };
  }
}

/**
 * Update undo stack after a new change
 */

async function updateUndoStackAfterChange(
  areaId: number,

  changeKey: ChangeKey,
): Promise<void> {
  const stack = await db.query.areaUndoStacks.findFirst({
    where: eq(areaUndoStacks.areaId, areaId),
  });

  if (!stack) {
    // Create new stack

    await db.insert(areaUndoStacks).values({
      areaId,

      undoStack: [changeKey],

      redoStack: [],
    });
  } else {
    // Add to undo stack and clear redo stack

    const currentUndoStack = (stack.undoStack as ChangeKey[]) || [];

    await db

      .update(areaUndoStacks)

      .set({
        undoStack: [...currentUndoStack, changeKey],

        redoStack: [], // Clear redo stack when new change is made

        updatedAt: new Date().toISOString(),
      })

      .where(eq(areaUndoStacks.id, stack.id));
  }
}

// ===============================

// UNDO/REDO OPERATIONS

// ===============================

/**
 * Undo the last change
 */

export async function undoChangeAction(
  areaId: number,
): ServerActionResponse<ChangeKey | { success: boolean; data: string }> {
  try {
    const result = await db.transaction(async (tx) => {
      // Get undo stack

      const stack = await tx.query.areaUndoStacks.findFirst({
        where: eq(areaUndoStacks.areaId, areaId),
      });

      if (!stack || !(stack.undoStack as ChangeKey[]).length) {
        throw new Error("No changes to undo");
      }

      const undoStack = stack.undoStack as ChangeKey[];

      const redoStack = (stack.redoStack as ChangeKey[]) || [];

      const changeKey = undoStack[undoStack.length - 1];

      if (
        !changeKey ||
        !changeKey.sequenceNumber ||
        !changeKey.versionNumber ||
        !changeKey.versionAreaId
      ) {
        return { success: false, data: "No changes to undo" };
      }

      // Get the change to undo

      const change = await tx.query.areaChanges.findFirst({
        where: and(
          eq(areaChanges.areaId, changeKey.areaId),

          eq(areaChanges.versionAreaId, changeKey.versionAreaId),

          eq(areaChanges.versionNumber, changeKey.versionNumber),

          eq(areaChanges.sequenceNumber, changeKey.sequenceNumber),
        ),
      });

      if (!change) {
        return { success: false, data: "No changes to undo" };
      }

      // Apply the undo operation

      await applyUndoOperation(tx, change);

      // Mark change as undone

      await tx

        .update(areaChanges)

        .set({ isUndone: "true" })

        .where(
          and(
            eq(areaChanges.areaId, changeKey.areaId),

            eq(areaChanges.versionAreaId, changeKey.versionAreaId),

            eq(areaChanges.versionNumber, changeKey.versionNumber),

            eq(areaChanges.sequenceNumber, changeKey.sequenceNumber),
          ),
        );

      // Update stacks

      await tx

        .update(areaUndoStacks)

        .set({
          undoStack: undoStack.slice(0, -1),

          redoStack: [...redoStack, changeKey],

          updatedAt: new Date().toISOString(),
        })

        .where(eq(areaUndoStacks.id, stack.id));

      return changeKey;
    });

    updateTag("undo-redo-status");

    return { success: true, data: result };
  } catch (error) {
    console.error("Error undoing change:", error);

    return {
      success: false,

      error: error instanceof Error ? error.message : "Failed to undo change",
    };
  }
}

/**
 * Redo the last undone change
 */

export async function redoChangeAction(
  areaId: number,
): ServerActionResponse<ChangeKey | { success: boolean; data: string }> {
  try {
    const result = await db.transaction(async (tx) => {
      // Get undo stack

      const stack = await tx.query.areaUndoStacks.findFirst({
        where: eq(areaUndoStacks.areaId, areaId),
      });

      if (!stack || !(stack.redoStack as ChangeKey[]).length) {
        throw new Error("No changes to redo");
      }

      const undoStack = (stack.undoStack as ChangeKey[]) || [];

      const redoStack = stack.redoStack as ChangeKey[];

      const changeKey = redoStack[redoStack.length - 1];

      if (
        !changeKey ||
        !changeKey.sequenceNumber ||
        !changeKey.versionNumber ||
        !changeKey.versionAreaId
      ) {
        return { success: false, data: "No changes to redo" };
      }

      // Get the change to redo

      const change = await tx.query.areaChanges.findFirst({
        where: and(
          eq(areaChanges.areaId, changeKey.areaId),

          eq(areaChanges.versionAreaId, changeKey.versionAreaId),

          eq(areaChanges.versionNumber, changeKey.versionNumber),

          eq(areaChanges.sequenceNumber, changeKey.sequenceNumber),
        ),
      });

      if (!change) {
        throw new Error("Change not found");
      }

      // Apply the redo operation

      await applyRedoOperation(tx, change);

      // Mark change as not undone

      await tx

        .update(areaChanges)

        .set({ isUndone: "false" })

        .where(
          and(
            eq(areaChanges.areaId, changeKey.areaId),

            eq(areaChanges.versionAreaId, changeKey.versionAreaId),

            eq(areaChanges.versionNumber, changeKey.versionNumber),

            eq(areaChanges.sequenceNumber, changeKey.sequenceNumber),
          ),
        );

      // Update stacks

      await tx

        .update(areaUndoStacks)

        .set({
          undoStack: [...undoStack, changeKey],

          redoStack: redoStack.slice(0, -1),

          updatedAt: new Date().toISOString(),
        })

        .where(eq(areaUndoStacks.id, stack.id));

      return changeKey;
    });

    updateTag("undo-redo-status");

    return { success: true, data: result };
  } catch (error) {
    console.error("Error redoing change:", error);

    return {
      success: false,

      error: error instanceof Error ? error.message : "Failed to redo change",
    };
  }
}

/**
 * Apply an undo operation based on change type
 */

async function applyUndoOperation(
  tx: Transaction,

  change: SelectAreaChanges,
): Promise<void> {
  const { changeType, entityId, previousData } = change;
  const typedPreviousData = previousData as PreviousDataWithLayer;
  const typedChangeData = change.changeData as ChangeDataWithLayer;

  switch (changeType) {
    case "create_layer":
      if (entityId) {
        // Delete the layer

        await tx

          .delete(areaLayerPostalCodes)

          .where(eq(areaLayerPostalCodes.layerId, entityId));

        await tx.delete(areaLayers).where(eq(areaLayers.id, entityId));
      }

      break;

    case "update_layer":
      if (entityId && previousData) {
        // Restore the previous state

        await tx

          .update(areaLayers)

          .set(previousData as Partial<typeof areaLayers.$inferInsert>)

          .where(eq(areaLayers.id, entityId));
      }

      break;

    case "delete_layer":
      if (previousData) {
        // Recreate the layer
        const typedPreviousData = previousData as PreviousDataWithLayer;

        const [layer] = await tx

          .insert(areaLayers)

          .values(typedPreviousData.layer!)

          .returning();

        // Recreate postal codes

        if (typedPreviousData.postalCodes && typedPreviousData.postalCodes.length > 0) {
          await tx.insert(areaLayerPostalCodes).values(
            typedPreviousData.postalCodes.map((code: string) => ({
              layerId: layer.id,

              postalCode: code,
            })),
          );
        }
      }

      break;

    case "add_postal_codes":
      if (entityId && typedChangeData?.postalCodes) {
        // Remove the postal codes

        await tx

          .delete(areaLayerPostalCodes)

          .where(
            and(
              eq(areaLayerPostalCodes.layerId, entityId),

              inArray(
                areaLayerPostalCodes.postalCode,

                typedChangeData.postalCodes,
              ),
            ),
          );
      }

      break;

    case "remove_postal_codes":
      if (entityId && typedPreviousData?.postalCodes) {
        // Re-add the postal codes

        await tx.insert(areaLayerPostalCodes).values(
          typedPreviousData.postalCodes.map((code: string) => ({
            layerId: entityId,

            postalCode: code,
          })),
        );
      }

      break;

    case "update_area":
      if (previousData) {
        await tx

          .update(areas)

          .set(previousData as Partial<typeof areas.$inferInsert>)

          .where(eq(areas.id, change.areaId));
      }

      break;
  }
}

/**
 * Apply a redo operation based on change type
 */

async function applyRedoOperation(
  tx: Transaction,

  change: SelectAreaChanges,
): Promise<void> {
  const { changeType, entityId, changeData } = change;
  const typedChangeData = changeData as ChangeDataWithLayer;

  switch (changeType) {
    case "create_layer":
      if (changeData) {
        // Recreate the layer
        const typedChangeData = changeData as ChangeDataWithLayer;

        const [layer] = await tx

          .insert(areaLayers)

          .values(typedChangeData.layer!)

          .returning();

        // Recreate postal codes

        if (typedChangeData.postalCodes && typedChangeData.postalCodes.length > 0) {
          await tx.insert(areaLayerPostalCodes).values(
            typedChangeData.postalCodes.map((code: string) => ({
              layerId: layer.id,

              postalCode: code,
            })),
          );
        }
      }

      break;

    case "update_layer":
      if (entityId && changeData) {
        await tx

          .update(areaLayers)

          .set(changeData as Partial<typeof areaLayers.$inferInsert>)

          .where(eq(areaLayers.id, entityId));
      }

      break;

    case "delete_layer":
      if (entityId) {
        await tx

          .delete(areaLayerPostalCodes)

          .where(eq(areaLayerPostalCodes.layerId, entityId));

        await tx.delete(areaLayers).where(eq(areaLayers.id, entityId));
      }

      break;

    case "add_postal_codes":
      if (entityId && typedChangeData?.postalCodes) {
        await tx.insert(areaLayerPostalCodes).values(
          typedChangeData.postalCodes.map((code: string) => ({
            layerId: entityId,

            postalCode: code,
          })),
        );
      }

      break;

    case "remove_postal_codes":
      if (entityId && typedChangeData?.postalCodes) {
        await tx

          .delete(areaLayerPostalCodes)

          .where(
            and(
              eq(areaLayerPostalCodes.layerId, entityId),

              inArray(areaLayerPostalCodes.postalCode, typedChangeData.postalCodes),
            ),
          );
      }

      break;

    case "update_area":
      if (changeData) {
        await tx

          .update(areas)

          .set(changeData as Partial<typeof areas.$inferInsert>)

          .where(eq(areas.id, change.areaId));
      }

      break;
  }
}

// ===============================

// CHANGE HISTORY & QUERIES

// ===============================

/**
 * Get change history for an area
 */

export async function getChangeHistoryAction(
  areaId: number,

  options?: {
    versionId?: number;

    limit?: number;

    includeUndone?: boolean;
  },
): ServerActionResponse<SelectAreaChanges[]> {
  try {
    let whereConditions = eq(areaChanges.areaId, areaId);

    if (options?.versionId) {
      // For now, we'll need to get the version first to get the composite key

      // This is a limitation of the current design - we might need to change this later

      const version = await db.query.areaVersions.findFirst({
        where: and(
          eq(areaVersions.areaId, areaId),

          eq(areaVersions.versionNumber, options.versionId),
        ),
      });

      if (version) {
        whereConditions = and(
          whereConditions,

          eq(areaChanges.versionAreaId, version.areaId),

          eq(areaChanges.versionNumber, version.versionNumber),
        )!;
      }
    }

    if (!options?.includeUndone) {
      whereConditions = and(
        whereConditions,

        eq(areaChanges.isUndone, "false"),
      )!;
    }

    let query = db

      .select()

      .from(areaChanges)

      .where(whereConditions)

      .orderBy(desc(areaChanges.sequenceNumber));

    if (options?.limit) {
      query = query.limit(options.limit) as unknown as typeof query;
    }

    const changes = await query;

    return { success: true, data: changes };
  } catch (error) {
    console.error("Error fetching change history:", error);

    return { success: false, error: "Failed to fetch change history" };
  }
}

/**
 * Get undo/redo stack status
 */

export const getUndoRedoStatusAction = unstable_cache(
  async (
    areaId: number,
  ): ServerActionResponse<{
    canUndo: boolean;

    canRedo: boolean;

    undoCount: number;

    redoCount: number;
  }> => {
    try {
      const stack = await db.query.areaUndoStacks.findFirst({
        where: eq(areaUndoStacks.areaId, areaId),
      });

      if (!stack) {
        return {
          success: true,

          data: { canUndo: false, canRedo: false, undoCount: 0, redoCount: 0 },
        };
      }

      const undoStack = (stack.undoStack as ChangeKey[]) || [];

      const redoStack = (stack.redoStack as ChangeKey[]) || [];

      return {
        success: true,

        data: {
          canUndo: undoStack.length > 0,

          canRedo: redoStack.length > 0,

          undoCount: undoStack.length,

          redoCount: redoStack.length,
        },
      };
    } catch (error) {
      console.error("Error getting undo/redo status:", error);

      return { success: false, error: "Failed to get undo/redo status" };
    }
  },

  ["undo-redo-status"],

  { tags: ["undo-redo-status"] },
);

/**
 * Clear undo/redo stacks (useful when creating a new version)
 */

export async function clearUndoRedoStacksAction(
  areaId: number,
): ServerActionResponse {
  try {
    const stack = await db.query.areaUndoStacks.findFirst({
      where: eq(areaUndoStacks.areaId, areaId),
    });

    if (stack) {
      await db

        .update(areaUndoStacks)

        .set({
          undoStack: [],

          redoStack: [],

          updatedAt: new Date().toISOString(),
        })

        .where(eq(areaUndoStacks.id, stack.id));
    }

    return { success: true };
  } catch (error) {
    console.error("Error clearing undo/redo stacks:", error);

    return { success: false, error: "Failed to clear undo/redo stacks" };
  }
}
